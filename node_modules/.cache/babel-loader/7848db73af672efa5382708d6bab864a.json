{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\CX\\\\OneDrive\\\\Coding\\\\hack20sitenew\\\\workout-buddy\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\CX\\\\OneDrive\\\\Coding\\\\hack20sitenew\\\\workout-buddy\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\CX\\\\OneDrive\\\\Coding\\\\hack20sitenew\\\\workout-buddy\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _inherits = require(\"C:\\\\Users\\\\CX\\\\OneDrive\\\\Coding\\\\hack20sitenew\\\\workout-buddy\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\CX\\\\OneDrive\\\\Coding\\\\hack20sitenew\\\\workout-buddy\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\n/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nvar debug = require('debug')('simple-peer');\n\nvar getBrowserRTC = require('get-browser-rtc');\n\nvar randombytes = require('randombytes');\n\nvar stream = require('readable-stream');\n\nvar queueMicrotask = require('queue-microtask'); // TODO: remove when Node 10 is not supported\n\n\nvar MAX_BUFFERED_AMOUNT = 64 * 1024;\nvar ICECOMPLETE_TIMEOUT = 5 * 1000;\nvar CHANNEL_CLOSING_TIMEOUT = 5 * 1000; // HACK: Filter trickle lines when trickle is disabled #354\n\nfunction filterTrickle(sdp) {\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '');\n}\n\nfunction makeError(err, code) {\n  if (typeof err === 'string') err = new Error(err);\n  if (err.error instanceof Error) err = err.error;\n  err.code = code;\n  return err;\n}\n\nfunction warn(message) {\n  console.warn(message);\n}\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\n\n\nvar Peer = /*#__PURE__*/function (_stream$Duplex) {\n  \"use strict\";\n\n  _inherits(Peer, _stream$Duplex);\n\n  var _super = _createSuper(Peer);\n\n  function Peer(opts) {\n    var _this;\n\n    _classCallCheck(this, Peer);\n\n    opts = Object.assign({\n      allowHalfOpen: false\n    }, opts);\n    _this = _super.call(this, opts);\n    _this._id = randombytes(4).toString('hex').slice(0, 7);\n\n    _this._debug('new peer %o', opts);\n\n    _this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString('hex') : null;\n    _this.initiator = opts.initiator || false;\n    _this.channelConfig = opts.channelConfig || Peer.channelConfig;\n    _this.negotiated = _this.channelConfig.negotiated;\n    _this.config = Object.assign({}, Peer.config, opts.config);\n    _this.offerOptions = opts.offerOptions || {};\n    _this.answerOptions = opts.answerOptions || {};\n\n    _this.sdpTransform = opts.sdpTransform || function (sdp) {\n      return sdp;\n    };\n\n    _this.streams = opts.streams || (opts.stream ? [opts.stream] : []); // support old \"stream\" option\n\n    _this.trickle = opts.trickle !== undefined ? opts.trickle : true;\n    _this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;\n    _this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;\n    _this.destroyed = false;\n    _this._connected = false;\n    _this.remoteAddress = undefined;\n    _this.remoteFamily = undefined;\n    _this.remotePort = undefined;\n    _this.localAddress = undefined;\n    _this.localFamily = undefined;\n    _this.localPort = undefined;\n    _this._wrtc = opts.wrtc && typeof opts.wrtc === 'object' ? opts.wrtc : getBrowserRTC();\n\n    if (!_this._wrtc) {\n      if (typeof window === 'undefined') {\n        throw makeError('No WebRTC support: Specify `opts.wrtc` option in this environment', 'ERR_WEBRTC_SUPPORT');\n      } else {\n        throw makeError('No WebRTC support: Not a supported browser', 'ERR_WEBRTC_SUPPORT');\n      }\n    }\n\n    _this._pcReady = false;\n    _this._channelReady = false;\n    _this._iceComplete = false; // ice candidate trickle done (got null candidate)\n\n    _this._iceCompleteTimer = null; // send an offer/answer anyway after some timeout\n\n    _this._channel = null;\n    _this._pendingCandidates = [];\n    _this._isNegotiating = _this.negotiated ? false : !_this.initiator; // is this peer waiting for negotiation to complete?\n\n    _this._batchedNegotiation = false; // batch synchronous negotiations\n\n    _this._queuedNegotiation = false; // is there a queued negotiation request?\n\n    _this._sendersAwaitingStable = [];\n    _this._senderMap = new Map();\n    _this._firstStable = true;\n    _this._closingInterval = null;\n    _this._remoteTracks = [];\n    _this._remoteStreams = [];\n    _this._chunk = null;\n    _this._cb = null;\n    _this._interval = null;\n\n    try {\n      _this._pc = new _this._wrtc.RTCPeerConnection(_this.config);\n    } catch (err) {\n      queueMicrotask(function () {\n        return _this.destroy(makeError(err, 'ERR_PC_CONSTRUCTOR'));\n      });\n      return _possibleConstructorReturn(_this);\n    } // We prefer feature detection whenever possible, but sometimes that's not\n    // possible for certain implementations.\n\n\n    _this._isReactNativeWebrtc = typeof _this._pc._peerConnectionId === 'number';\n\n    _this._pc.oniceconnectionstatechange = function () {\n      _this._onIceStateChange();\n    };\n\n    _this._pc.onicegatheringstatechange = function () {\n      _this._onIceStateChange();\n    };\n\n    _this._pc.onconnectionstatechange = function () {\n      _this._onConnectionStateChange();\n    };\n\n    _this._pc.onsignalingstatechange = function () {\n      _this._onSignalingStateChange();\n    };\n\n    _this._pc.onicecandidate = function (event) {\n      _this._onIceCandidate(event);\n    }; // Other spec events, unused by this implementation:\n    // - onconnectionstatechange\n    // - onicecandidateerror\n    // - onfingerprintfailure\n    // - onnegotiationneeded\n\n\n    if (_this.initiator || _this.negotiated) {\n      _this._setupData({\n        channel: _this._pc.createDataChannel(_this.channelName, _this.channelConfig)\n      });\n    } else {\n      _this._pc.ondatachannel = function (event) {\n        _this._setupData(event);\n      };\n    }\n\n    if (_this.streams) {\n      _this.streams.forEach(function (stream) {\n        _this.addStream(stream);\n      });\n    }\n\n    _this._pc.ontrack = function (event) {\n      _this._onTrack(event);\n    };\n\n    if (_this.initiator) {\n      _this._needsNegotiation();\n    }\n\n    _this._onFinishBound = function () {\n      _this._onFinish();\n    };\n\n    _this.once('finish', _this._onFinishBound);\n\n    return _this;\n  }\n\n  _createClass(Peer, [{\n    key: \"address\",\n    value: function address() {\n      return {\n        port: this.localPort,\n        family: this.localFamily,\n        address: this.localAddress\n      };\n    }\n  }, {\n    key: \"signal\",\n    value: function signal(data) {\n      var _this2 = this;\n\n      if (this.destroyed) throw makeError('cannot signal after peer is destroyed', 'ERR_SIGNALING');\n\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          data = {};\n        }\n      }\n\n      this._debug('signal()');\n\n      if (data.renegotiate && this.initiator) {\n        this._debug('got request to renegotiate');\n\n        this._needsNegotiation();\n      }\n\n      if (data.transceiverRequest && this.initiator) {\n        this._debug('got request for transceiver');\n\n        this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);\n      }\n\n      if (data.candidate) {\n        if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n          this._addIceCandidate(data.candidate);\n        } else {\n          this._pendingCandidates.push(data.candidate);\n        }\n      }\n\n      if (data.sdp) {\n        this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(function () {\n          if (_this2.destroyed) return;\n\n          _this2._pendingCandidates.forEach(function (candidate) {\n            _this2._addIceCandidate(candidate);\n          });\n\n          _this2._pendingCandidates = [];\n          if (_this2._pc.remoteDescription.type === 'offer') _this2._createAnswer();\n        }).catch(function (err) {\n          _this2.destroy(makeError(err, 'ERR_SET_REMOTE_DESCRIPTION'));\n        });\n      }\n\n      if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n        this.destroy(makeError('signal() called with invalid signal data', 'ERR_SIGNALING'));\n      }\n    }\n  }, {\n    key: \"_addIceCandidate\",\n    value: function _addIceCandidate(candidate) {\n      var _this3 = this;\n\n      var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);\n\n      this._pc.addIceCandidate(iceCandidateObj).catch(function (err) {\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\n          warn('Ignoring unsupported ICE candidate.');\n        } else {\n          _this3.destroy(makeError(err, 'ERR_ADD_ICE_CANDIDATE'));\n        }\n      });\n    }\n    /**\r\n     * Send text/binary data to the remote peer.\r\n     * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\r\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(chunk) {\n      this._channel.send(chunk);\n    }\n    /**\r\n     * Add a Transceiver to the connection.\r\n     * @param {String} kind\r\n     * @param {Object} init\r\n     */\n\n  }, {\n    key: \"addTransceiver\",\n    value: function addTransceiver(kind, init) {\n      this._debug('addTransceiver()');\n\n      if (this.initiator) {\n        try {\n          this._pc.addTransceiver(kind, init);\n\n          this._needsNegotiation();\n        } catch (err) {\n          this.destroy(makeError(err, 'ERR_ADD_TRANSCEIVER'));\n        }\n      } else {\n        this.emit('signal', {\n          // request initiator to renegotiate\n          transceiverRequest: {\n            kind,\n            init\n          }\n        });\n      }\n    }\n    /**\r\n     * Add a MediaStream to the connection.\r\n     * @param {MediaStream} stream\r\n     */\n\n  }, {\n    key: \"addStream\",\n    value: function addStream(stream) {\n      var _this4 = this;\n\n      this._debug('addStream()');\n\n      stream.getTracks().forEach(function (track) {\n        _this4.addTrack(track, stream);\n      });\n    }\n    /**\r\n     * Add a MediaStreamTrack to the connection.\r\n     * @param {MediaStreamTrack} track\r\n     * @param {MediaStream} stream\r\n     */\n\n  }, {\n    key: \"addTrack\",\n    value: function addTrack(track, stream) {\n      this._debug('addTrack()');\n\n      var submap = this._senderMap.get(track) || new Map(); // nested Maps map [track, stream] to sender\n\n      var sender = submap.get(stream);\n\n      if (!sender) {\n        sender = this._pc.addTrack(track, stream);\n        submap.set(stream, sender);\n\n        this._senderMap.set(track, submap);\n\n        this._needsNegotiation();\n      } else if (sender.removed) {\n        throw makeError('Track has been removed. You should enable/disable tracks that you want to re-add.', 'ERR_SENDER_REMOVED');\n      } else {\n        throw makeError('Track has already been added to that stream.', 'ERR_SENDER_ALREADY_ADDED');\n      }\n    }\n    /**\r\n     * Replace a MediaStreamTrack by another in the connection.\r\n     * @param {MediaStreamTrack} oldTrack\r\n     * @param {MediaStreamTrack} newTrack\r\n     * @param {MediaStream} stream\r\n     */\n\n  }, {\n    key: \"replaceTrack\",\n    value: function replaceTrack(oldTrack, newTrack, stream) {\n      this._debug('replaceTrack()');\n\n      var submap = this._senderMap.get(oldTrack);\n\n      var sender = submap ? submap.get(stream) : null;\n\n      if (!sender) {\n        throw makeError('Cannot replace track that was never added.', 'ERR_TRACK_NOT_ADDED');\n      }\n\n      if (newTrack) this._senderMap.set(newTrack, submap);\n\n      if (sender.replaceTrack != null) {\n        sender.replaceTrack(newTrack);\n      } else {\n        this.destroy(makeError('replaceTrack is not supported in this browser', 'ERR_UNSUPPORTED_REPLACETRACK'));\n      }\n    }\n    /**\r\n     * Remove a MediaStreamTrack from the connection.\r\n     * @param {MediaStreamTrack} track\r\n     * @param {MediaStream} stream\r\n     */\n\n  }, {\n    key: \"removeTrack\",\n    value: function removeTrack(track, stream) {\n      this._debug('removeSender()');\n\n      var submap = this._senderMap.get(track);\n\n      var sender = submap ? submap.get(stream) : null;\n\n      if (!sender) {\n        throw makeError('Cannot remove track that was never added.', 'ERR_TRACK_NOT_ADDED');\n      }\n\n      try {\n        sender.removed = true;\n\n        this._pc.removeTrack(sender);\n      } catch (err) {\n        if (err.name === 'NS_ERROR_UNEXPECTED') {\n          this._sendersAwaitingStable.push(sender); // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n\n        } else {\n          this.destroy(makeError(err, 'ERR_REMOVE_TRACK'));\n        }\n      }\n\n      this._needsNegotiation();\n    }\n    /**\r\n     * Remove a MediaStream from the connection.\r\n     * @param {MediaStream} stream\r\n     */\n\n  }, {\n    key: \"removeStream\",\n    value: function removeStream(stream) {\n      var _this5 = this;\n\n      this._debug('removeSenders()');\n\n      stream.getTracks().forEach(function (track) {\n        _this5.removeTrack(track, stream);\n      });\n    }\n  }, {\n    key: \"_needsNegotiation\",\n    value: function _needsNegotiation() {\n      var _this6 = this;\n\n      this._debug('_needsNegotiation');\n\n      if (this._batchedNegotiation) return; // batch synchronous renegotiations\n\n      this._batchedNegotiation = true;\n      queueMicrotask(function () {\n        _this6._batchedNegotiation = false;\n\n        _this6._debug('starting batched negotiation');\n\n        _this6.negotiate();\n      });\n    }\n  }, {\n    key: \"negotiate\",\n    value: function negotiate() {\n      var _this7 = this;\n\n      if (this.initiator) {\n        if (this._isNegotiating) {\n          this._queuedNegotiation = true;\n\n          this._debug('already negotiating, queueing');\n        } else {\n          this._debug('start negotiation');\n\n          setTimeout(function () {\n            // HACK: Chrome crashes if we immediately call createOffer\n            _this7._createOffer();\n          }, 0);\n        }\n      } else {\n        if (this._isNegotiating) {\n          this._queuedNegotiation = true;\n\n          this._debug('already negotiating, queueing');\n        } else {\n          this._debug('requesting negotiation from initiator');\n\n          this.emit('signal', {\n            // request initiator to renegotiate\n            renegotiate: true\n          });\n        }\n      }\n\n      this._isNegotiating = true;\n    } // TODO: Delete this method once readable-stream is updated to contain a default\n    // implementation of destroy() that automatically calls _destroy()\n    // See: https://github.com/nodejs/readable-stream/issues/283\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(err) {\n      this._destroy(err, function () {});\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err, cb) {\n      if (this.destroyed) return;\n\n      this._debug('destroy (error: %s)', err && (err.message || err));\n\n      this.readable = this.writable = false;\n      if (!this._readableState.ended) this.push(null);\n      if (!this._writableState.finished) this.end();\n      this.destroyed = true;\n      this._connected = false;\n      this._pcReady = false;\n      this._channelReady = false;\n      this._remoteTracks = null;\n      this._remoteStreams = null;\n      this._senderMap = null;\n      clearInterval(this._closingInterval);\n      this._closingInterval = null;\n      clearInterval(this._interval);\n      this._interval = null;\n      this._chunk = null;\n      this._cb = null;\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound);\n      this._onFinishBound = null;\n\n      if (this._channel) {\n        try {\n          this._channel.close();\n        } catch (err) {}\n\n        this._channel.onmessage = null;\n        this._channel.onopen = null;\n        this._channel.onclose = null;\n        this._channel.onerror = null;\n      }\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (err) {}\n\n        this._pc.oniceconnectionstatechange = null;\n        this._pc.onicegatheringstatechange = null;\n        this._pc.onsignalingstatechange = null;\n        this._pc.onicecandidate = null;\n        this._pc.ontrack = null;\n        this._pc.ondatachannel = null;\n      }\n\n      this._pc = null;\n      this._channel = null;\n      if (err) this.emit('error', err);\n      this.emit('close');\n      cb();\n    }\n  }, {\n    key: \"_setupData\",\n    value: function _setupData(event) {\n      var _this8 = this;\n\n      if (!event.channel) {\n        // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n        // which is invalid behavior. Handle it gracefully.\n        // See: https://github.com/feross/simple-peer/issues/163\n        return this.destroy(makeError('Data channel event is missing `channel` property', 'ERR_DATA_CHANNEL'));\n      }\n\n      this._channel = event.channel;\n      this._channel.binaryType = 'arraybuffer';\n\n      if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n        this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;\n      }\n\n      this.channelName = this._channel.label;\n\n      this._channel.onmessage = function (event) {\n        _this8._onChannelMessage(event);\n      };\n\n      this._channel.onbufferedamountlow = function () {\n        _this8._onChannelBufferedAmountLow();\n      };\n\n      this._channel.onopen = function () {\n        _this8._onChannelOpen();\n      };\n\n      this._channel.onclose = function () {\n        _this8._onChannelClose();\n      };\n\n      this._channel.onerror = function (err) {\n        _this8.destroy(makeError(err, 'ERR_DATA_CHANNEL'));\n      }; // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n\n\n      var isClosing = false;\n      this._closingInterval = setInterval(function () {\n        // No \"onclosing\" event\n        if (_this8._channel && _this8._channel.readyState === 'closing') {\n          if (isClosing) _this8._onChannelClose(); // closing timed out: equivalent to onclose firing\n\n          isClosing = true;\n        } else {\n          isClosing = false;\n        }\n      }, CHANNEL_CLOSING_TIMEOUT);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {}\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, cb) {\n      if (this.destroyed) return cb(makeError('cannot write after peer is destroyed', 'ERR_DATA_CHANNEL'));\n\n      if (this._connected) {\n        try {\n          this.send(chunk);\n        } catch (err) {\n          return this.destroy(makeError(err, 'ERR_DATA_CHANNEL'));\n        }\n\n        if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n          this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount);\n\n          this._cb = cb;\n        } else {\n          cb(null);\n        }\n      } else {\n        this._debug('write before connect');\n\n        this._chunk = chunk;\n        this._cb = cb;\n      }\n    } // When stream finishes writing, close socket. Half open connections are not\n    // supported.\n\n  }, {\n    key: \"_onFinish\",\n    value: function _onFinish() {\n      var _this9 = this;\n\n      if (this.destroyed) return; // Wait a bit before destroying so the socket flushes.\n      // TODO: is there a more reliable way to accomplish this?\n\n      var destroySoon = function destroySoon() {\n        setTimeout(function () {\n          return _this9.destroy();\n        }, 1000);\n      };\n\n      if (this._connected) {\n        destroySoon();\n      } else {\n        this.once('connect', destroySoon);\n      }\n    }\n  }, {\n    key: \"_startIceCompleteTimeout\",\n    value: function _startIceCompleteTimeout() {\n      var _this10 = this;\n\n      if (this.destroyed) return;\n      if (this._iceCompleteTimer) return;\n\n      this._debug('started iceComplete timeout');\n\n      this._iceCompleteTimer = setTimeout(function () {\n        if (!_this10._iceComplete) {\n          _this10._iceComplete = true;\n\n          _this10._debug('iceComplete timeout completed');\n\n          _this10.emit('iceTimeout');\n\n          _this10.emit('_iceComplete');\n        }\n      }, this.iceCompleteTimeout);\n    }\n  }, {\n    key: \"_createOffer\",\n    value: function _createOffer() {\n      var _this11 = this;\n\n      if (this.destroyed) return;\n\n      this._pc.createOffer(this.offerOptions).then(function (offer) {\n        if (_this11.destroyed) return;\n        if (!_this11.trickle && !_this11.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);\n        offer.sdp = _this11.sdpTransform(offer.sdp);\n\n        var sendOffer = function sendOffer() {\n          if (_this11.destroyed) return;\n          var signal = _this11._pc.localDescription || offer;\n\n          _this11._debug('signal');\n\n          _this11.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          });\n        };\n\n        var onSuccess = function onSuccess() {\n          _this11._debug('createOffer success');\n\n          if (_this11.destroyed) return;\n          if (_this11.trickle || _this11._iceComplete) sendOffer();else _this11.once('_iceComplete', sendOffer); // wait for candidates\n        };\n\n        var onError = function onError(err) {\n          _this11.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'));\n        };\n\n        _this11._pc.setLocalDescription(offer).then(onSuccess).catch(onError);\n      }).catch(function (err) {\n        _this11.destroy(makeError(err, 'ERR_CREATE_OFFER'));\n      });\n    }\n  }, {\n    key: \"_requestMissingTransceivers\",\n    value: function _requestMissingTransceivers() {\n      var _this12 = this;\n\n      if (this._pc.getTransceivers) {\n        this._pc.getTransceivers().forEach(function (transceiver) {\n          if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n            transceiver.requested = true; // HACK: Safari returns negotiated transceivers with a null mid\n\n            _this12.addTransceiver(transceiver.sender.track.kind);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_createAnswer\",\n    value: function _createAnswer() {\n      var _this13 = this;\n\n      if (this.destroyed) return;\n\n      this._pc.createAnswer(this.answerOptions).then(function (answer) {\n        if (_this13.destroyed) return;\n        if (!_this13.trickle && !_this13.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);\n        answer.sdp = _this13.sdpTransform(answer.sdp);\n\n        var sendAnswer = function sendAnswer() {\n          if (_this13.destroyed) return;\n          var signal = _this13._pc.localDescription || answer;\n\n          _this13._debug('signal');\n\n          _this13.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          });\n\n          if (!_this13.initiator) _this13._requestMissingTransceivers();\n        };\n\n        var onSuccess = function onSuccess() {\n          if (_this13.destroyed) return;\n          if (_this13.trickle || _this13._iceComplete) sendAnswer();else _this13.once('_iceComplete', sendAnswer);\n        };\n\n        var onError = function onError(err) {\n          _this13.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'));\n        };\n\n        _this13._pc.setLocalDescription(answer).then(onSuccess).catch(onError);\n      }).catch(function (err) {\n        _this13.destroy(makeError(err, 'ERR_CREATE_ANSWER'));\n      });\n    }\n  }, {\n    key: \"_onConnectionStateChange\",\n    value: function _onConnectionStateChange() {\n      if (this.destroyed) return;\n\n      if (this._pc.connectionState === 'failed') {\n        this.destroy(makeError('Connection failed.', 'ERR_CONNECTION_FAILURE'));\n      }\n    }\n  }, {\n    key: \"_onIceStateChange\",\n    value: function _onIceStateChange() {\n      if (this.destroyed) return;\n      var iceConnectionState = this._pc.iceConnectionState;\n      var iceGatheringState = this._pc.iceGatheringState;\n\n      this._debug('iceStateChange (connection: %s) (gathering: %s)', iceConnectionState, iceGatheringState);\n\n      this.emit('iceStateChange', iceConnectionState, iceGatheringState);\n\n      if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n        this._pcReady = true;\n\n        this._maybeReady();\n      }\n\n      if (iceConnectionState === 'failed') {\n        this.destroy(makeError('Ice connection failed.', 'ERR_ICE_CONNECTION_FAILURE'));\n      }\n\n      if (iceConnectionState === 'closed') {\n        this.destroy(makeError('Ice connection closed.', 'ERR_ICE_CONNECTION_CLOSED'));\n      }\n    }\n  }, {\n    key: \"getStats\",\n    value: function getStats(cb) {\n      var _this14 = this;\n\n      // statreports can come with a value array instead of properties\n      var flattenValues = function flattenValues(report) {\n        if (Object.prototype.toString.call(report.values) === '[object Array]') {\n          report.values.forEach(function (value) {\n            Object.assign(report, value);\n          });\n        }\n\n        return report;\n      }; // Promise-based getStats() (standard)\n\n\n      if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n        this._pc.getStats().then(function (res) {\n          var reports = [];\n          res.forEach(function (report) {\n            reports.push(flattenValues(report));\n          });\n          cb(null, reports);\n        }, function (err) {\n          return cb(err);\n        }); // Single-parameter callback-based getStats() (non-standard)\n\n      } else if (this._pc.getStats.length > 0) {\n        this._pc.getStats(function (res) {\n          // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n          if (_this14.destroyed) return;\n          var reports = [];\n          res.result().forEach(function (result) {\n            var report = {};\n            result.names().forEach(function (name) {\n              report[name] = result.stat(name);\n            });\n            report.id = result.id;\n            report.type = result.type;\n            report.timestamp = result.timestamp;\n            reports.push(flattenValues(report));\n          });\n          cb(null, reports);\n        }, function (err) {\n          return cb(err);\n        }); // Unknown browser, skip getStats() since it's anyone's guess which style of\n        // getStats() they implement.\n\n      } else {\n        cb(null, []);\n      }\n    }\n  }, {\n    key: \"_maybeReady\",\n    value: function _maybeReady() {\n      var _this15 = this;\n\n      this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady);\n\n      if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;\n      this._connecting = true; // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n\n      var findCandidatePair = function findCandidatePair() {\n        if (_this15.destroyed) return;\n\n        _this15.getStats(function (err, items) {\n          if (_this15.destroyed) return; // Treat getStats error as non-fatal. It's not essential.\n\n          if (err) items = [];\n          var remoteCandidates = {};\n          var localCandidates = {};\n          var candidatePairs = {};\n          var foundSelectedCandidatePair = false;\n          items.forEach(function (item) {\n            // TODO: Once all browsers support the hyphenated stats report types, remove\n            // the non-hypenated ones\n            if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\n              remoteCandidates[item.id] = item;\n            }\n\n            if (item.type === 'localcandidate' || item.type === 'local-candidate') {\n              localCandidates[item.id] = item;\n            }\n\n            if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n              candidatePairs[item.id] = item;\n            }\n          });\n\n          var setSelectedCandidatePair = function setSelectedCandidatePair(selectedCandidatePair) {\n            foundSelectedCandidatePair = true;\n            var local = localCandidates[selectedCandidatePair.localCandidateId];\n\n            if (local && (local.ip || local.address)) {\n              // Spec\n              _this15.localAddress = local.ip || local.address;\n              _this15.localPort = Number(local.port);\n            } else if (local && local.ipAddress) {\n              // Firefox\n              _this15.localAddress = local.ipAddress;\n              _this15.localPort = Number(local.portNumber);\n            } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n              // TODO: remove this once Chrome 58 is released\n              local = selectedCandidatePair.googLocalAddress.split(':');\n              _this15.localAddress = local[0];\n              _this15.localPort = Number(local[1]);\n            }\n\n            if (_this15.localAddress) {\n              _this15.localFamily = _this15.localAddress.includes(':') ? 'IPv6' : 'IPv4';\n            }\n\n            var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];\n\n            if (remote && (remote.ip || remote.address)) {\n              // Spec\n              _this15.remoteAddress = remote.ip || remote.address;\n              _this15.remotePort = Number(remote.port);\n            } else if (remote && remote.ipAddress) {\n              // Firefox\n              _this15.remoteAddress = remote.ipAddress;\n              _this15.remotePort = Number(remote.portNumber);\n            } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n              // TODO: remove this once Chrome 58 is released\n              remote = selectedCandidatePair.googRemoteAddress.split(':');\n              _this15.remoteAddress = remote[0];\n              _this15.remotePort = Number(remote[1]);\n            }\n\n            if (_this15.remoteAddress) {\n              _this15.remoteFamily = _this15.remoteAddress.includes(':') ? 'IPv6' : 'IPv4';\n            }\n\n            _this15._debug('connect local: %s:%s remote: %s:%s', _this15.localAddress, _this15.localPort, _this15.remoteAddress, _this15.remotePort);\n          };\n\n          items.forEach(function (item) {\n            // Spec-compliant\n            if (item.type === 'transport' && item.selectedCandidatePairId) {\n              setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);\n            } // Old implementations\n\n\n            if (item.type === 'googCandidatePair' && item.googActiveConnection === 'true' || (item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected) {\n              setSelectedCandidatePair(item);\n            }\n          }); // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n          // But wait until at least 1 candidate pair is available\n\n          if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n            setTimeout(findCandidatePair, 100);\n            return;\n          } else {\n            _this15._connecting = false;\n            _this15._connected = true;\n          }\n\n          if (_this15._chunk) {\n            try {\n              _this15.send(_this15._chunk);\n            } catch (err) {\n              return _this15.destroy(makeError(err, 'ERR_DATA_CHANNEL'));\n            }\n\n            _this15._chunk = null;\n\n            _this15._debug('sent chunk from \"write before connect\"');\n\n            var cb = _this15._cb;\n            _this15._cb = null;\n            cb(null);\n          } // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n          // fallback to using setInterval to implement backpressure.\n\n\n          if (typeof _this15._channel.bufferedAmountLowThreshold !== 'number') {\n            _this15._interval = setInterval(function () {\n              return _this15._onInterval();\n            }, 150);\n            if (_this15._interval.unref) _this15._interval.unref();\n          }\n\n          _this15._debug('connect');\n\n          _this15.emit('connect');\n        });\n      };\n\n      findCandidatePair();\n    }\n  }, {\n    key: \"_onInterval\",\n    value: function _onInterval() {\n      if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n        return;\n      }\n\n      this._onChannelBufferedAmountLow();\n    }\n  }, {\n    key: \"_onSignalingStateChange\",\n    value: function _onSignalingStateChange() {\n      var _this16 = this;\n\n      if (this.destroyed) return;\n\n      if (this._pc.signalingState === 'stable' && !this._firstStable) {\n        this._isNegotiating = false; // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n\n        this._debug('flushing sender queue', this._sendersAwaitingStable);\n\n        this._sendersAwaitingStable.forEach(function (sender) {\n          _this16._pc.removeTrack(sender);\n\n          _this16._queuedNegotiation = true;\n        });\n\n        this._sendersAwaitingStable = [];\n\n        if (this._queuedNegotiation) {\n          this._debug('flushing negotiation queue');\n\n          this._queuedNegotiation = false;\n\n          this._needsNegotiation(); // negotiate again\n\n        }\n\n        this._debug('negotiate');\n\n        this.emit('negotiate');\n      }\n\n      this._firstStable = false;\n\n      this._debug('signalingStateChange %s', this._pc.signalingState);\n\n      this.emit('signalingStateChange', this._pc.signalingState);\n    }\n  }, {\n    key: \"_onIceCandidate\",\n    value: function _onIceCandidate(event) {\n      if (this.destroyed) return;\n\n      if (event.candidate && this.trickle) {\n        this.emit('signal', {\n          candidate: {\n            candidate: event.candidate.candidate,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            sdpMid: event.candidate.sdpMid\n          }\n        });\n      } else if (!event.candidate && !this._iceComplete) {\n        this._iceComplete = true;\n        this.emit('_iceComplete');\n      } // as soon as we've received one valid candidate start timeout\n\n\n      if (event.candidate) {\n        this._startIceCompleteTimeout();\n      }\n    }\n  }, {\n    key: \"_onChannelMessage\",\n    value: function _onChannelMessage(event) {\n      if (this.destroyed) return;\n      var data = event.data;\n      if (data instanceof ArrayBuffer) data = Buffer.from(data);\n      this.push(data);\n    }\n  }, {\n    key: \"_onChannelBufferedAmountLow\",\n    value: function _onChannelBufferedAmountLow() {\n      if (this.destroyed || !this._cb) return;\n\n      this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount);\n\n      var cb = this._cb;\n      this._cb = null;\n      cb(null);\n    }\n  }, {\n    key: \"_onChannelOpen\",\n    value: function _onChannelOpen() {\n      if (this._connected || this.destroyed) return;\n\n      this._debug('on channel open');\n\n      this._channelReady = true;\n\n      this._maybeReady();\n    }\n  }, {\n    key: \"_onChannelClose\",\n    value: function _onChannelClose() {\n      if (this.destroyed) return;\n\n      this._debug('on channel close');\n\n      this.destroy();\n    }\n  }, {\n    key: \"_onTrack\",\n    value: function _onTrack(event) {\n      var _this17 = this;\n\n      if (this.destroyed) return;\n      event.streams.forEach(function (eventStream) {\n        _this17._debug('on track');\n\n        _this17.emit('track', event.track, eventStream);\n\n        _this17._remoteTracks.push({\n          track: event.track,\n          stream: eventStream\n        });\n\n        if (_this17._remoteStreams.some(function (remoteStream) {\n          return remoteStream.id === eventStream.id;\n        })) return; // Only fire one 'stream' event, even though there may be multiple tracks per stream\n\n        _this17._remoteStreams.push(eventStream);\n\n        queueMicrotask(function () {\n          _this17.emit('stream', eventStream); // ensure all tracks have been added\n\n        });\n      });\n    }\n  }, {\n    key: \"_debug\",\n    value: function _debug() {\n      var args = [].slice.call(arguments);\n      args[0] = '[' + this._id + '] ' + args[0];\n      debug.apply(null, args);\n    }\n  }, {\n    key: \"bufferSize\",\n    get: function get() {\n      return this._channel && this._channel.bufferedAmount || 0;\n    } // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this._connected && this._channel.readyState === 'open';\n    }\n  }]);\n\n  return Peer;\n}(stream.Duplex);\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC();\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\n\nPeer.config = {\n  iceServers: [{\n    urls: 'stun:stun.l.google.com:19302'\n  }, {\n    urls: 'stun:global.stun.twilio.com:3478?transport=udp'\n  }],\n  sdpSemantics: 'unified-plan'\n};\nPeer.channelConfig = {};\nmodule.exports = Peer;","map":{"version":3,"sources":["C:/Users/CX/OneDrive/Coding/hack20sitenew/workout-buddy/node_modules/simple-peer/index.js"],"names":["debug","require","getBrowserRTC","randombytes","stream","queueMicrotask","MAX_BUFFERED_AMOUNT","ICECOMPLETE_TIMEOUT","CHANNEL_CLOSING_TIMEOUT","filterTrickle","sdp","replace","makeError","err","code","Error","error","warn","message","console","Peer","opts","Object","assign","allowHalfOpen","_id","toString","slice","_debug","channelName","initiator","channelConfig","negotiated","config","offerOptions","answerOptions","sdpTransform","streams","trickle","undefined","allowHalfTrickle","iceCompleteTimeout","destroyed","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","_wrtc","wrtc","window","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_senderMap","Map","_firstStable","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","_pc","RTCPeerConnection","destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","_setupData","channel","createDataChannel","ondatachannel","forEach","addStream","ontrack","_onTrack","_needsNegotiation","_onFinishBound","_onFinish","once","port","family","address","data","JSON","parse","renegotiate","transceiverRequest","addTransceiver","kind","init","candidate","remoteDescription","type","_addIceCandidate","push","setRemoteDescription","RTCSessionDescription","then","_createAnswer","catch","iceCandidateObj","RTCIceCandidate","addIceCandidate","endsWith","chunk","send","emit","getTracks","track","addTrack","submap","get","sender","set","removed","oldTrack","newTrack","replaceTrack","removeTrack","name","negotiate","setTimeout","_createOffer","_destroy","cb","readable","writable","_readableState","ended","_writableState","finished","end","clearInterval","removeListener","close","onmessage","onopen","onclose","onerror","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","isClosing","setInterval","readyState","encoding","bufferedAmount","destroySoon","createOffer","offer","sendOffer","signal","localDescription","onSuccess","onError","setLocalDescription","getTransceivers","transceiver","mid","requested","createAnswer","answer","sendAnswer","_requestMissingTransceivers","connectionState","iceConnectionState","iceGatheringState","_maybeReady","flattenValues","report","prototype","call","values","value","getStats","length","res","reports","result","names","stat","id","timestamp","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","Number","ipAddress","portNumber","googLocalAddress","split","includes","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","keys","_onInterval","unref","signalingState","sdpMLineIndex","sdpMid","_startIceCompleteTimeout","ArrayBuffer","Buffer","from","eventStream","some","remoteStream","args","arguments","apply","Duplex","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics","module","exports"],"mappings":"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","sourcesContent":["/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nvar debug = require('debug')('simple-peer')\r\nvar getBrowserRTC = require('get-browser-rtc')\r\nvar randombytes = require('randombytes')\r\nvar stream = require('readable-stream')\r\nvar queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported\r\n\r\nvar MAX_BUFFERED_AMOUNT = 64 * 1024\r\nvar ICECOMPLETE_TIMEOUT = 5 * 1000\r\nvar CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction makeError (err, code) {\r\n  if (typeof err === 'string') err = new Error(err)\r\n  if (err.error instanceof Error) err = err.error\r\n  err.code = code\r\n  return err\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends stream.Duplex {\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this._id = randombytes(4).toString('hex').slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || randombytes(20).toString('hex')\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.negotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this.destroyed = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')\r\n      ? opts.wrtc\r\n      : getBrowserRTC()\r\n\r\n    if (!this._wrtc) {\r\n      if (typeof window === 'undefined') {\r\n        throw makeError('No WebRTC support: Specify `opts.wrtc` option in this environment', 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw makeError('No WebRTC support: Not a supported browser', 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = this.negotiated ? false : !this.initiator // is this peer waiting for negotiation to complete?\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._senderMap = new Map()\r\n    this._firstStable = true\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)\r\n    } catch (err) {\r\n      queueMicrotask(() => this.destroy(makeError(err, 'ERR_PC_CONSTRUCTOR')))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.negotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    if (this.streams) {\r\n      this.streams.forEach(stream => {\r\n        this.addStream(stream)\r\n      })\r\n    }\r\n    this._pc.ontrack = event => {\r\n      this._onTrack(event)\r\n    }\r\n\r\n    if (this.initiator) {\r\n      this._needsNegotiation()\r\n    }\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this.destroyed) throw makeError('cannot signal after peer is destroyed', 'ERR_SIGNALING')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.destroy(makeError(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.destroy(makeError('signal() called with invalid signal data', 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.destroy(makeError(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  /**\r\n   * Add a Transceiver to the connection.\r\n   * @param {String} kind\r\n   * @param {Object} init\r\n   */\r\n  addTransceiver (kind, init) {\r\n    this._debug('addTransceiver()')\r\n\r\n    if (this.initiator) {\r\n      try {\r\n        this._pc.addTransceiver(kind, init)\r\n        this._needsNegotiation()\r\n      } catch (err) {\r\n        this.destroy(makeError(err, 'ERR_ADD_TRANSCEIVER'))\r\n      }\r\n    } else {\r\n      this.emit('signal', { // request initiator to renegotiate\r\n        transceiverRequest: { kind, init }\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a MediaStream to the connection.\r\n   * @param {MediaStream} stream\r\n   */\r\n  addStream (stream) {\r\n    this._debug('addStream()')\r\n\r\n    stream.getTracks().forEach(track => {\r\n      this.addTrack(track, stream)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Add a MediaStreamTrack to the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */\r\n  addTrack (track, stream) {\r\n    this._debug('addTrack()')\r\n\r\n    var submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\r\n    var sender = submap.get(stream)\r\n    if (!sender) {\r\n      sender = this._pc.addTrack(track, stream)\r\n      submap.set(stream, sender)\r\n      this._senderMap.set(track, submap)\r\n      this._needsNegotiation()\r\n    } else if (sender.removed) {\r\n      throw makeError('Track has been removed. You should enable/disable tracks that you want to re-add.', 'ERR_SENDER_REMOVED')\r\n    } else {\r\n      throw makeError('Track has already been added to that stream.', 'ERR_SENDER_ALREADY_ADDED')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replace a MediaStreamTrack by another in the connection.\r\n   * @param {MediaStreamTrack} oldTrack\r\n   * @param {MediaStreamTrack} newTrack\r\n   * @param {MediaStream} stream\r\n   */\r\n  replaceTrack (oldTrack, newTrack, stream) {\r\n    this._debug('replaceTrack()')\r\n\r\n    var submap = this._senderMap.get(oldTrack)\r\n    var sender = submap ? submap.get(stream) : null\r\n    if (!sender) {\r\n      throw makeError('Cannot replace track that was never added.', 'ERR_TRACK_NOT_ADDED')\r\n    }\r\n    if (newTrack) this._senderMap.set(newTrack, submap)\r\n\r\n    if (sender.replaceTrack != null) {\r\n      sender.replaceTrack(newTrack)\r\n    } else {\r\n      this.destroy(makeError('replaceTrack is not supported in this browser', 'ERR_UNSUPPORTED_REPLACETRACK'))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a MediaStreamTrack from the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */\r\n  removeTrack (track, stream) {\r\n    this._debug('removeSender()')\r\n\r\n    var submap = this._senderMap.get(track)\r\n    var sender = submap ? submap.get(stream) : null\r\n    if (!sender) {\r\n      throw makeError('Cannot remove track that was never added.', 'ERR_TRACK_NOT_ADDED')\r\n    }\r\n    try {\r\n      sender.removed = true\r\n      this._pc.removeTrack(sender)\r\n    } catch (err) {\r\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\r\n        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\r\n      } else {\r\n        this.destroy(makeError(err, 'ERR_REMOVE_TRACK'))\r\n      }\r\n    }\r\n    this._needsNegotiation()\r\n  }\r\n\r\n  /**\r\n   * Remove a MediaStream from the connection.\r\n   * @param {MediaStream} stream\r\n   */\r\n  removeStream (stream) {\r\n    this._debug('removeSenders()')\r\n\r\n    stream.getTracks().forEach(track => {\r\n      this.removeTrack(track, stream)\r\n    })\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      this._debug('starting batched negotiation')\r\n      this.negotiate()\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  // TODO: Delete this method once readable-stream is updated to contain a default\r\n  // implementation of destroy() that automatically calls _destroy()\r\n  // See: https://github.com/nodejs/readable-stream/issues/283\r\n  destroy (err) {\r\n    this._destroy(err, () => {})\r\n  }\r\n\r\n  _destroy (err, cb) {\r\n    if (this.destroyed) return\r\n\r\n    this._debug('destroy (error: %s)', err && (err.message || err))\r\n\r\n    this.readable = this.writable = false\r\n\r\n    if (!this._readableState.ended) this.push(null)\r\n    if (!this._writableState.finished) this.end()\r\n\r\n    this.destroyed = true\r\n    this._connected = false\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._remoteTracks = null\r\n    this._remoteStreams = null\r\n    this._senderMap = null\r\n\r\n    clearInterval(this._closingInterval)\r\n    this._closingInterval = null\r\n\r\n    clearInterval(this._interval)\r\n    this._interval = null\r\n    this._chunk = null\r\n    this._cb = null\r\n\r\n    if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n    this._onFinishBound = null\r\n\r\n    if (this._channel) {\r\n      try {\r\n        this._channel.close()\r\n      } catch (err) {}\r\n\r\n      this._channel.onmessage = null\r\n      this._channel.onopen = null\r\n      this._channel.onclose = null\r\n      this._channel.onerror = null\r\n    }\r\n    if (this._pc) {\r\n      try {\r\n        this._pc.close()\r\n      } catch (err) {}\r\n\r\n      this._pc.oniceconnectionstatechange = null\r\n      this._pc.onicegatheringstatechange = null\r\n      this._pc.onsignalingstatechange = null\r\n      this._pc.onicecandidate = null\r\n      this._pc.ontrack = null\r\n      this._pc.ondatachannel = null\r\n    }\r\n    this._pc = null\r\n    this._channel = null\r\n\r\n    if (err) this.emit('error', err)\r\n    this.emit('close')\r\n    cb()\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.destroy(makeError('Data channel event is missing `channel` property', 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = err => {\r\n      this.destroy(makeError(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    var isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _read () {}\r\n\r\n  _write (chunk, encoding, cb) {\r\n    if (this.destroyed) return cb(makeError('cannot write after peer is destroyed', 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(makeError(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          var signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.destroy(makeError(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _requestMissingTransceivers () {\r\n    if (this._pc.getTransceivers) {\r\n      this._pc.getTransceivers().forEach(transceiver => {\r\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\r\n          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\r\n          this.addTransceiver(transceiver.sender.track.kind)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          var signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.destroy(makeError(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.destroy(makeError('Connection failed.', 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    var iceConnectionState = this._pc.iceConnectionState\r\n    var iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.destroy(makeError('Ice connection failed.', 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.destroy(makeError('Ice connection closed.', 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          var reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        var reports = []\r\n        res.result().forEach(result => {\r\n          var report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        var remoteCandidates = {}\r\n        var localCandidates = {}\r\n        var candidatePairs = {}\r\n        var foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          var local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress, this.localPort, this.remoteAddress, this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.destroy(makeError(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          var cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable' && !this._firstStable) {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      }\r\n\r\n      this._debug('negotiate')\r\n      this.emit('negotiate')\r\n    }\r\n    this._firstStable = false\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    var data = event.data\r\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    var cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.destroy()\r\n  }\r\n\r\n  _onTrack (event) {\r\n    if (this.destroyed) return\r\n\r\n    event.streams.forEach(eventStream => {\r\n      this._debug('on track')\r\n      this.emit('track', event.track, eventStream)\r\n\r\n      this._remoteTracks.push({\r\n        track: event.track,\r\n        stream: eventStream\r\n      })\r\n\r\n      if (this._remoteStreams.some(remoteStream => {\r\n        return remoteStream.id === eventStream.id\r\n      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream\r\n\r\n      this._remoteStreams.push(eventStream)\r\n      queueMicrotask(() => {\r\n        this.emit('stream', eventStream) // ensure all tracks have been added\r\n      })\r\n    })\r\n  }\r\n\r\n  _debug () {\r\n    var args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC()\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: 'stun:stun.l.google.com:19302'\r\n    },\r\n    {\r\n      urls: 'stun:global.stun.twilio.com:3478?transport=udp'\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nmodule.exports = Peer\r\n"]},"metadata":{},"sourceType":"script"}